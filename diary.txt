Notes:
Jobs list:
Report - contents page (chronological vs categories?)
Category functionality:
- database migration to add a template-category table
- story_builder_service changes to ensure that categories are added when new templates are saved and when stories are made using the template.
Response searching and sorting:
- ability to navigate from selected stories to see responses related to them.
- ability to search by keyword (in story or response?)
- ability to search responses by the category of the story sent
Response exporting
- ability to select columns (user designs their own report)?
Models and Providers:
- Ability to add and edit providers and models - creating a provider factory
- Changes to database provider and model tables to include code needed tof the prompt
- how does that work with imports like "from groq import Groq"? is "lazy loading" the answer?
Testing

***Session vs URL
*Benefits of Using Session
-Cleaner URLs: URLs become shorter and more readable
-State Persistence: User preferences persist across page refreshes
-Security: Sensitive parameters aren't visible in the URL
-Flexibility: Easier to add or remove parameters without changing URL structure
*Caveats and Considerations
-Session Size: Don't store large datasets in the session
-Bookmarking: URLs without parameters can't be bookmarked with specific filters
-Sharing: URLs without parameters can't be easily shared with specific views
-User Expectations: Users expect the back button to maintain their state
*Hybrid Approach
-For the best experience, consider a hybrid approach:
-Use session for processing state, jobs, and selected items
-Keep search and filtering parameters in URLs for bookmarking/sharing
-Add a "Save filters as default" option that stores preferences in the session



** 26/02/25 - stories working up to generating stories from template, then breaking as it is mixed up in the sending stories to LLM route. 
Generated stories are being added to the database its, when it then tries to re-route to "do you want to send them to the LLM" stuff it breaks. 



Story id and question id still being passed in URLS (check templates).
Display of LLM response now working correctly with correct provider and model name. 


Add to project diary:
\Users\AnneO'Leary\OneDrive - Institute for Research in Schools\Documents\Projects\LLM\Automated-Prompting-LLM\app\services\llm_service.py:18: SAWarning: relationship 'WordField.field' will copy column field.field_id to column word_field.field_id, which conflicts with relationship(s): 'Field.words' (copies field.field_id to word_field.field_id), 'Word.fields' (copies field.field_id to word_field.field_id). If this is not the intention, consider if these relationships should be linked with back_populates, or if viewonly=True should be applied to one or more if they are read-only. For the less common case that foreign key constraints are partially overlapping, the orm.foreign() annotation can be used to isolate the columns that should be written towards. To silence this warning, add the parameter 'overlaps="fields,words"' to the 'WordField.field' relationship. (Background on this warning at: https://sqlalche.me/e/20/qzyx) (This warning originated from the configure_mappers() process, which was invoked automatically in response to a user-initiated operation.)

GitHub Copilot
This warning from SQLAlchemy indicates that there is a conflict in the relationships defined in your models. Specifically, the WordField.field relationship is trying to copy the field_id column to the word_field.field_id column, which conflicts with other relationships that also copy field_id to word_field.field_id.

Explanation
Conflicting Relationships: The warning mentions that the WordField.field relationship will copy field.field_id to word_field.field_id, which conflicts with the Field.words and Word.fields relationships that also copy field.field_id to word_field.field_id.

Possible Solutions:

Use back_populates: Link the relationships with back_populates to explicitly define the bidirectional relationships.
Use viewonly=True: Apply viewonly=True to one or more relationships if they are read-only.
Use overlaps: Add the overlaps parameter to the WordField.field relationship to silence the warning.

Using back_populates
Pros:

Explicit Bidirectional Relationships: back_populates explicitly defines the bidirectional nature of the relationship, making the code more readable and understandable.
Automatic Synchronization: Changes in one side of the relationship are automatically reflected in the other side, ensuring data consistency.
Clear Relationship Definition: It provides a clear and explicit way to define how two models are related to each other.
Cons:

More Verbose: Requires additional lines of code to define the relationships on both sides.
Potential for Cyclic Imports: If not managed properly, defining relationships in both models can lead to cyclic import issues.
Using overlaps
Pros:

Simple Solution: Adding the overlaps parameter is a quick and simple way to silence the warning without changing the existing relationship definitions.
Minimal Code Changes: Requires minimal changes to the existing code, making it easier to implement.
Cons:

Less Explicit: The overlaps parameter does not explicitly define the bidirectional nature of the relationship, which can make the code less readable and harder to understand.
Potential for Hidden Issues: Silencing the warning without addressing the underlying issue might lead to hidden bugs or inconsistencies in the data.
Summary
back_populates is a more explicit and robust way to define bidirectional relationships, ensuring data consistency and clarity in the code. However, it requires more code and careful management to avoid cyclic imports.
overlaps is a simpler and quicker solution to silence the warning, but it is less explicit and might hide underlying issues
Notes:

Checking coverage terminal commands:
coverage run -m pytest
coverage report
coverage html


pytest tests/unit/test_models/test_story.py -v
pytest tests/unit/test_models/test_question.py -v
pytest tests/unit/test_models/test_prompt_response.py -v
pytest tests/unit/test_models/template/test_word.py -v
pytest tests/unit/test_models/template/test_field.py -v

Jobs list:
Report - contents page (chronological vs categories?)
Category functionality:
- database migration to add a template-category table
- story_builder_service changes to ensure that categories are added when new templates are saved and when stories are made using the template.
Models confusion reduction:
- database migration to rename a table LLMModel or similar.
Response searching and sorting:
- ability to navigate from selected stories to see responses related to them.
- ability to search by keyword (in story or response?)
- ability to search responses by the category of the story sent
Response exporting
- ability to select columns (user designs their own report)?
Models and Providers:
- Ability to add and edit providers and models - creating a provider factory
- Changes to database provider and model tables to include code needed tof the prompt
- how does that work with imports like "from groq import Groq"? is "lazy loading" the answer?
Testing
Solve problem 

Reworking routes and tidying (using session and not), removing redundant methods and/or moving out to services from routes

Timeout on the loading page. 

Linting with changes as needed.

***Session vs URL
*Benefits of Using Session
-Cleaner URLs: URLs become shorter and more readable
-State Persistence: User preferences persist across page refreshes
-Security: Sensitive parameters aren't visible in the URL
-Flexibility: Easier to add or remove parameters without changing URL structure
*Caveats and Considerations
-Session Size: Don't store large datasets in the session
-Bookmarking: URLs without parameters can't be bookmarked with specific filters
-Sharing: URLs without parameters can't be easily shared with specific views
-User Expectations: Users expect the back button to maintain their state
*Hybrid Approach
-For the best experience, consider a hybrid approach:
-Use session for processing state, jobs, and selected items
-Keep search and filtering parameters in URLs for bookmarking/sharing
-Add a "Save filters as default" option that stores preferences in the session



*****LOGIC BEHIND STARTING TO USE JSON:****
Use of JSON in a Flask Application
Using JSON in a Flask application that renders templates directly (without a formal API structure) is actually quite common and represents a hybrid approach that many modern web applications use.

Why JSON is Used in Flask Template-Based Apps
Even when using server-side rendering with templates, there are several scenarios where JSON becomes useful:

AJAX Requests: Your application uses fetch() in JavaScript to make asynchronous requests to your Flask server (like in addWordsToField() and deleteWordFromDatabase()). These requests need a structured data format, and JSON is ideal for this.

Form Data Storage: You're storing complex nested data structures (like your fieldData object) in hidden form fields as JSON strings, which is the standard way to include structured data in form submissions.

State Management: You're maintaining client-side state (in your JavaScript variables) and occasionally need to synchronize that with the server.

Specific Examples in Your Code
Your code shows a few typical patterns:

Client → Server: Sending data to the server with JSON:
fetch('/add_word', {
    method: 'POST',
    headers: {
        'Content-Type': 'application/json',
    },
    body: JSON.stringify({
        field_name: fieldName,
        new_words: wordsString,
    }),
})
Server → Client: Receiving JSON responses:
.then(response => response.json())
.then(data => {
    if (data.success) {
        console.log(`Words added to field "${fieldName}": ${wordsString}`);
    }
})
Form Submission: Storing complex data in a form field:
function updateFieldDataJson() {
    fieldDataInput.value = JSON.stringify(fieldData);
}

Is This Typical?
Yes, this is very typical in modern Flask applications. The pattern you're using is sometimes called:

Progressive Enhancement: Starting with server-rendered templates, then adding dynamic JavaScript functionality

Hybrid Rendering: Using both server-side templates and client-side JavaScript updates

Many Flask applications do exactly what you're doing:

Render the initial page with Jinja2 templates
Use JavaScript for interactivity
Use AJAX/fetch with JSON for data updates without full page reloads
This approach gives you the best of both worlds: the simplicity of server-rendered templates with the interactivity of client-side JavaScript.

Modern Alternatives
The main alternatives would be:

Pure API: Separate your Flask app into a backend API (returning only JSON) and a frontend SPA (Single Page Application)
Pure Server Rendering: Eliminate most JavaScript and reload the page for any data change
Your approach (server templates + JSON for updates) is a practical middle ground that works well for many applications.
***********************************************************************************

String vs Integer for Story IDs in Session
Using strings for story IDs in your session is indeed the better approach for several reasons:

Benefits of Using Strings for Session IDs
Consistency: HTTP parameters from forms are always strings. Using strings consistently avoids type mismatches when comparing values.

Flask Sessions: Flask session serializes data to JSON, where all object keys are strings. This can sometimes lead to subtle inconsistencies when mixing types.

Form Values: HTML form inputs always send values as strings. Your deselect button is submitting value="{{ story.story_id }}" which is a string.

Equality Comparison: In Python, "1" != 1 - this is a common source of bugs when mixing types.

Implementation Approach
The best approach is to:

Always store IDs as strings in the session
Convert to integers only when querying the database
Convert back to strings when adding IDs to the session


** 26/02/25 - stories working up to generating stories from template, then breaking as it is mixed up in the sending stories to LLM route. 
Generated stories are being added to the database its, when it then tries to re-route to "do you want to send them to the LLM" stuff it breaks. 



Story id and question id still being passed in URLS (check templates).
Display of LLM response now working correctly with correct provider and model name. 


Add to project diary:
\Users\AnneO'Leary\OneDrive - Institute for Research in Schools\Documents\Projects\LLM\Automated-Prompting-LLM\app\services\llm_service.py:18: SAWarning: relationship 'WordField.field' will copy column field.field_id to column word_field.field_id, which conflicts with relationship(s): 'Field.words' (copies field.field_id to word_field.field_id), 'Word.fields' (copies field.field_id to word_field.field_id). If this is not the intention, consider if these relationships should be linked with back_populates, or if viewonly=True should be applied to one or more if they are read-only. For the less common case that foreign key constraints are partially overlapping, the orm.foreign() annotation can be used to isolate the columns that should be written towards. To silence this warning, add the parameter 'overlaps="fields,words"' to the 'WordField.field' relationship. (Background on this warning at: https://sqlalche.me/e/20/qzyx) (This warning originated from the configure_mappers() process, which was invoked automatically in response to a user-initiated operation.)

GitHub Copilot
This warning from SQLAlchemy indicates that there is a conflict in the relationships defined in your models. Specifically, the WordField.field relationship is trying to copy the field_id column to the word_field.field_id column, which conflicts with other relationships that also copy field_id to word_field.field_id.

Explanation
Conflicting Relationships: The warning mentions that the WordField.field relationship will copy field.field_id to word_field.field_id, which conflicts with the Field.words and Word.fields relationships that also copy field.field_id to word_field.field_id.

Possible Solutions:

Use back_populates: Link the relationships with back_populates to explicitly define the bidirectional relationships.
Use viewonly=True: Apply viewonly=True to one or more relationships if they are read-only.
Use overlaps: Add the overlaps parameter to the WordField.field relationship to silence the warning.

Using back_populates
Pros:

Explicit Bidirectional Relationships: back_populates explicitly defines the bidirectional nature of the relationship, making the code more readable and understandable.
Automatic Synchronization: Changes in one side of the relationship are automatically reflected in the other side, ensuring data consistency.
Clear Relationship Definition: It provides a clear and explicit way to define how two models are related to each other.
Cons:

More Verbose: Requires additional lines of code to define the relationships on both sides.
Potential for Cyclic Imports: If not managed properly, defining relationships in both models can lead to cyclic import issues.
Using overlaps
Pros:

Simple Solution: Adding the overlaps parameter is a quick and simple way to silence the warning without changing the existing relationship definitions.
Minimal Code Changes: Requires minimal changes to the existing code, making it easier to implement.
Cons:

Less Explicit: The overlaps parameter does not explicitly define the bidirectional nature of the relationship, which can make the code less readable and harder to understand.
Potential for Hidden Issues: Silencing the warning without addressing the underlying issue might lead to hidden bugs or inconsistencies in the data.
Summary
back_populates is a more explicit and robust way to define bidirectional relationships, ensuring data consistency and clarity in the code. However, it requires more code and careful management to avoid cyclic imports.
overlaps is a simpler and quicker solution to silence the warning, but it is less explicit and might hide underlying issues